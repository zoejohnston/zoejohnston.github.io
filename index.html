<!DOCTYPE html>
<html>

<script id="vertex-shader" type="x-shader/x-vertex">
    #ifdef GL_ES
      precision highp float;
    #endif

    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;

    varying vec2 vScrollLeft;
    varying vec2 vScrollRight;
    varying vec2 vTextureCoord;

    uniform float time;
  
    void main() {
      gl_Position = vec4(aVertexPosition, 0.0, 1.0);

      vScrollLeft = aTextureCoord + vec2(time, time);
      vScrollRight = aTextureCoord + vec2(-time, time) + 0.2;
      vTextureCoord = aTextureCoord;
    }
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
    #ifdef GL_ES
      precision highp float;
    #endif

    varying vec2 vScrollLeft;
    varying vec2 vScrollRight;
    varying vec2 vTextureCoord;

    uniform float time;
  
    uniform vec4 uGlobalColor;
    uniform sampler2D texture0;
    uniform sampler2D texture1;
  
    void main() {
        vec4 displacementMap = texture2D(texture1, vScrollLeft);
        vec4 baseColor = texture2D(texture0, vScrollRight + 0.2 * (displacementMap.r - 0.5));
        
        vec4 leftNoise = texture2D(texture1, vScrollLeft);
        vec4 rightNoise = texture2D(texture1, vScrollRight);
        vec4 waterHighlights = mix(leftNoise, rightNoise, 0.5);

        vec4 water;
        if (waterHighlights.r < 0.45) {
            water = baseColor + 0.1 * vec4(0.93, 0.78, 0.38, 0.0);

        } else if (waterHighlights.r > 0.66) {
            water = baseColor + 0.4 * vec4(0.93, 0.78, 0.38, 0.0);

        } else {
            water = baseColor;
        }

        float randomIntensity = fract(10000.0 * sin(vTextureCoord.x + vTextureCoord.y * 8000.0 * fract(time)));
        randomIntensity -= 0.5;
        water.rb += 0.4 * randomIntensity;
        randomIntensity = fract(10000.0 * sin(vTextureCoord.x + vTextureCoord.y * 6000.0 * fract(time)));
        randomIntensity -= 0.5;
        water.g += 0.1 * randomIntensity;

        gl_FragColor = water;
    }
</script>

<script src="index.js" type="module"></script>

<style>
    @font-face {
    font-family: 'gladifiltheftegladifilthefte';
    src: url('Gladifilthefte-webfont.woff') format('woff');
    font-weight: normal;
    font-style: normal;
    }
    div.overtop {
        position: absolute; 
        left: 0; 
        right: 0; 
        margin-left: auto; 
        margin-right: auto; 
        width: 800px;
    }
    div.list {
        width: 800px;
        margin: auto;
    }
    div.main {
        width: 800px;
        margin: auto;
        text-align: center;
    }
    body {
        background-color: #fef9c2;
        font-weight: bold;
        font-family: 'Courier New', Courier, monospace;
        font-size: 16px;
        color:#fc98a4;
    }
    div.overtop>h1 {
        text-align: center;
        color:#fc98a4;
        font-size: 80px;
        text-shadow: #fc98a4 1px 0 10px;
        font-family:'trebuchet ms';
    }
    h1 {
        text-align: left;
        color:#fc98a4;
        font-size: 40px;
        font-family:'trebuchet ms';
    }
    div.row {
        padding: 10px;
        width: 800px;
        margin: auto;
    }
    div.row>h2 {
        font-weight: bold;
        float: left;
        width: 33.33%;
        font-size: 16px;
        color:#fc98a4;
        font-family: 'Courier New', Courier, monospace;
    }
    img.column3 {
        float: left;
        width: 33.33%;
        margin-right: 20px;
    }
    img.column1 {
        float: left;
        margin-right: 20px;
    }
    div.project {
        border-radius: 25px;
        padding: 5px;
    }
    h2.column1 {
        text-align: left;
    }
    h2.column2 {
        text-align: center;
    }
    h2.column3 {
        text-align: right;
    }
    p {
        text-align: left;
    }
    p.short {
        width: 600px;
    }
    canvas {
        border-radius: 25px;
        padding-left: 0;
        padding-right: 0;
        padding-bottom: 10px;;
        margin-left: auto;
        margin-right: auto;
        display: block;
    }  
    img {
        border-radius: 25px;
    }
    li {
        display: inline;
        padding: 10px 10px;
    } 
    li a {
        color: #fc98a4;
        text-decoration: none; 
    }
    li a:hover {
        color: #b1e1a3;
    }
    .row:after {
        content: "";
        display: table;
        clear: both;
    }

</style>

<header>
    <div class="row">
        <h2 class="column1">ZOELISEJOHNSTON@GMAIL.COM<br>LINKEDIN.COM/IN/ZOELISEJOHNSTON</h2>
        <h2 class="column2">PORTFOLIO</h2>
        <h2 class="column3">RESUME<br>CV</h2>
    </div>
</header>

<body>
    <div class="overtop">
        <h1>Zoe Johnston</h1>
    </div>

    <canvas id="glcanvas" width="800" height="260">
        Oh no! Your browser doesn't support canvas!
    </canvas>

    <div class="main">
        <p class="short">Hi, I'm Zoe. I'm a recent computer science graduate interested in 
        computer graphics, animation, low-level programming, and art. Have a look
        through some of my work!</p>
        <div class="project">
            <h1>Yarn-Level Cloth Simulation</h1>
            <p>Some of the properties of fabric, especially knit fabric, come from the sliding of 
                inidvidual yarns. Runs are an obvious example of yarn-level movement in woven fabric. 
                One yarn gets caught and is forced to slide past the yarns that it is woven through, 
                deforming the fabric in a characteristic way. The question behind this project was: "how 
                can we go about simulating fabric at this level of detail?". I read a few papers on 
                the subject, and decided to replicate the technique for simulating woven fabric used by Cirio et al. in a 2014 paper.
                <br><br>
                Like many cloth simulation methods, this method uses a particle-based discretization of the farbic.
                Each yarn crossing is described using a particle with five degrees of freedom. Three degrees of 
                freedom describe the location of the particle in 3D space and two describe its parametric location
                along the two yarns that make up the crossing that it describes.
                Using a force model, we can then update particle coordinates over time. I just used Verlet integratrion 
                to do this, but more efficient methods exist
                <br><br>
                In the pictures below, you can see the resting positions of two sheets of woven farbic. By varying the amount
                of friction, we get different amounts of sliding.
            </p>
            <div class="row">
                <img class="column3" src="nosliding.png">
                <img class="column3" src="sliding.png">
            </div>
            <p>As I mentioned before, runs are a great example of yarn level movement! To create the picture below, I slowly decreased the length
                of one yarn.
            </p>
            <div class="row">
                <img class="column1" src="run2.png">
            </div>
        </div>
    </div>
</body>

</html>
